"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getIdentifierName = exports.isNodeTranslated = exports.hasAncestorWithName = exports.getQuasisValue = exports.isTTaggedTemplateExpression = exports.getNearestAncestor = exports.isAllowedDOMAttr = exports.isLinguiTags = exports.containAllAttributes = exports.isSvgTag = exports.isNativeDOMTag = exports.isUpperCase = void 0;
const utils_1 = require("@typescript-eslint/utils");
const constants_1 = require("./constants");
function isUpperCase(str) {
    return /^[A-Z_-]+$/.test(str);
}
exports.isUpperCase = isUpperCase;
function isNativeDOMTag(str) {
    return constants_1.DOM_TAGS.includes(str);
}
exports.isNativeDOMTag = isNativeDOMTag;
function isSvgTag(str) {
    return constants_1.SVG_TAGS.includes(str);
}
exports.isSvgTag = isSvgTag;
function containAllAttributes(attributeNames) {
    const attrs = ['value', 'other'];
    return attrs.every((attr) => attributeNames.includes(attr));
}
exports.containAllAttributes = containAllAttributes;
function isLinguiTags(str, attributeNames) {
    if (str === 'Trans') {
        return true;
    }
    return ['Plural', 'Select'].includes(str) && containAllAttributes(attributeNames);
}
exports.isLinguiTags = isLinguiTags;
const blacklistAttrs = ['placeholder', 'alt', 'aria-label', 'value'];
function isAllowedDOMAttr(tag, attr, attributeNames) {
    if (isSvgTag(tag))
        return true;
    if (isNativeDOMTag(tag)) {
        return !blacklistAttrs.includes(attr);
    }
    if (isLinguiTags(tag, attributeNames)) {
        return true;
    }
    return false;
}
exports.isAllowedDOMAttr = isAllowedDOMAttr;
function getNearestAncestor(node, type) {
    let temp = node.parent;
    while (temp) {
        if (temp.type === type) {
            return temp;
        }
        temp = temp.parent;
    }
    return null;
}
exports.getNearestAncestor = getNearestAncestor;
const isTTaggedTemplateExpression = (node) => {
    switch (node === null || node === void 0 ? void 0 : node.type) {
        case utils_1.TSESTree.AST_NODE_TYPES.TaggedTemplateExpression:
            if (node.tag.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
                const tagName = node.tag.name;
                if (tagName === 't') {
                    return true;
                }
            }
        default:
            return false;
    }
};
exports.isTTaggedTemplateExpression = isTTaggedTemplateExpression;
const getQuasisValue = (node, trim = true) => {
    if (node.quasis) {
        const quasisCookedArray = node.quasis.map((quasis) => quasis.value.cooked);
        const cookedArrayString = quasisCookedArray.join('');
        if (trim) {
            return cookedArrayString.trim();
        }
        return cookedArrayString;
    }
    return '';
};
exports.getQuasisValue = getQuasisValue;
function hasAncestorWithName(node, name) {
    var _a;
    let p = node.parent;
    while (p) {
        switch (p.type) {
            case utils_1.TSESTree.AST_NODE_TYPES.JSXElement:
                const identifierName = getIdentifierName((_a = p === null || p === void 0 ? void 0 : p.openingElement) === null || _a === void 0 ? void 0 : _a.name);
                if (identifierName === name) {
                    return true;
                }
            default:
        }
        p = p.parent;
    }
    return false;
}
exports.hasAncestorWithName = hasAncestorWithName;
function isNodeTranslated(node) {
    if (hasAncestorWithName(node, 'Trans')) {
        return true;
    }
    const taggedTemplate = getNearestAncestor(node, 'TaggedTemplateExpression');
    return taggedTemplate ? (0, exports.isTTaggedTemplateExpression)(taggedTemplate) : false;
}
exports.isNodeTranslated = isNodeTranslated;
function getIdentifierName(jsxTagNameExpression) {
    switch (jsxTagNameExpression.type) {
        case utils_1.TSESTree.AST_NODE_TYPES.JSXIdentifier:
            return jsxTagNameExpression.name;
        default:
            return null;
    }
}
exports.getIdentifierName = getIdentifierName;
//# sourceMappingURL=helpers.js.map