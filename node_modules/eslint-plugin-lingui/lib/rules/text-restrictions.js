"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const helpers_1 = require("../helpers");
const rule = {
    meta: {
        docs: {
            description: 'Text restrictions',
            recommended: 'error',
        },
        messages: {
            default: '{{ message }}',
        },
        schema: [
            {
                type: 'object',
                properties: {
                    rules: {
                        type: 'array',
                        items: {
                            type: 'object',
                            properties: {
                                patterns: {
                                    type: 'array',
                                    items: {
                                        type: 'string',
                                    },
                                },
                                flags: {
                                    type: 'string',
                                },
                                message: {
                                    type: 'string',
                                },
                                isOnlyForTranslation: {
                                    type: 'boolean',
                                },
                            },
                        },
                    },
                },
                additionalProperties: false,
            },
        ],
        type: 'problem',
    },
    defaultOptions: [],
    create: function (context) {
        const { options: [option], } = context;
        if (option && option.rules) {
            const { rules } = option;
            const rulePatterns = rules.map(({ patterns, message, flags, isOnlyForTranslation }) => ({
                patterns: patterns.map((item) => new RegExp(item, flags)),
                message,
                isOnlyForTranslation,
            }));
            const onLiteral = (value, node) => {
                rulePatterns.forEach(({ patterns, message, isOnlyForTranslation }) => {
                    if (isOnlyForTranslation && !(0, helpers_1.isNodeTranslated)(node)) {
                        return;
                    }
                    if (patterns.some((item) => {
                        return item.test(value);
                    })) {
                        context.report({ node, messageId: 'default', data: { message: message } });
                    }
                });
            };
            return {
                'TemplateLiteral:exit'(node) {
                    const quasisValue = (0, helpers_1.getQuasisValue)(node);
                    onLiteral(quasisValue.trim(), node);
                    return;
                },
                'Literal, JSXText'(node) {
                    if (node.value) {
                        const trimed = node.value.toString().trim();
                        onLiteral(trimed, node);
                    }
                    return;
                },
            };
        }
    },
};
exports.default = rule;
//# sourceMappingURL=text-restrictions.js.map