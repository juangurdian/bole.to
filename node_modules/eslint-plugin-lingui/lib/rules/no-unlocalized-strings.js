"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("@typescript-eslint/utils");
const helpers_1 = require("../helpers");
const rule = {
    meta: {
        docs: {
            description: 'disallow literal string',
            recommended: 'error',
        },
        messages: {
            default: '{{ message }}',
        },
        schema: [
            {
                type: 'object',
                properties: {
                    ignore: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                    ignoreFunction: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                    ignoreAttribute: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                    ignoreProperty: {
                        type: 'array',
                        items: {
                            type: 'string',
                        },
                    },
                },
                additionalProperties: false,
            },
        ],
        type: 'problem',
    },
    defaultOptions: [],
    create: function (context) {
        // variables should be defined here
        const { parserServices, options: [option], } = context;
        const whitelists = [
            /^[^A-Za-z]+$/,
            ...((option && option.ignore) || []),
        ].map((item) => new RegExp(item));
        const calleeWhitelists = generateCalleeWhitelists(option);
        const message = 'disallow literal string';
        //----------------------------------------------------------------------
        // Helpers
        //----------------------------------------------------------------------
        function isStrMatched(str) {
            const mainAcceptanceRegex = /((^[A-Z]{1}.*?)|(\w*?\s\w*?.*?))/;
            const lettersRegex = /[a-z]/;
            return str && mainAcceptanceRegex.test(str) && lettersRegex.test(str);
        }
        function match(str) {
            return whitelists.some((item) => item.test(str));
        }
        function isValidFunctionCall({ callee, }) {
            switch (callee.type) {
                case utils_1.TSESTree.AST_NODE_TYPES.MemberExpression: {
                    if (callee.property.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier &&
                        callee.object.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
                        if (calleeWhitelists.simple.indexOf(callee.property.name) !== -1) {
                            return true;
                        }
                        const calleeName = `${callee.object.name}.${callee.property.name}`;
                        return calleeWhitelists.complex.indexOf(calleeName) !== -1;
                    }
                    return false;
                }
                case utils_1.TSESTree.AST_NODE_TYPES.Identifier: {
                    if (callee.name === 'require') {
                        return true;
                    }
                    return calleeWhitelists.simple.indexOf(callee.name) !== -1;
                }
                case utils_1.TSESTree.AST_NODE_TYPES.CallExpression: {
                    return ((callee.callee.type === utils_1.TSESTree.AST_NODE_TYPES.MemberExpression ||
                        callee.callee.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) &&
                        isValidFunctionCall(callee));
                }
                default:
                    return false;
            }
        }
        const ignoredClassProperties = ['displayName'];
        const ignoredJSXElements = ['Trans'];
        const ignoredJSXSymbols = ['&larr;', '&nbsp;', '&middot;'];
        const ignoredAttributes = (option && option.ignoreAttribute) || [];
        const userJSXAttrs = [
            'className',
            'styleName',
            'type',
            'id',
            'width',
            'height',
            ...ignoredAttributes,
        ];
        const ignoredProperties = (option && option.ignoreProperty) || [];
        const userProperties = [
            'className',
            'styleName',
            'type',
            'id',
            'width',
            'height',
            ...ignoredProperties,
        ];
        //----------------------------------------------------------------------
        // Public
        //----------------------------------------------------------------------
        const visited = new WeakSet();
        function isString(node) {
            switch (node.type) {
                case utils_1.TSESTree.AST_NODE_TYPES.Literal:
                    return typeof node.value === 'string';
                case utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral:
                    return Boolean(node.quasis);
                case utils_1.TSESTree.AST_NODE_TYPES.JSXText:
                    return true;
                default:
                    return false;
            }
        }
        const { esTreeNodeToTSNodeMap, program } = parserServices;
        let typeChecker;
        if (program && esTreeNodeToTSNodeMap) {
            typeChecker = program.getTypeChecker();
        }
        const getAttrName = (node) => {
            if (typeof node === 'string') {
                return node;
            }
            return node === null || node === void 0 ? void 0 : node.name;
        };
        const onJSXAttribute = (node) => {
            var _a, _b;
            const parent = (0, helpers_1.getNearestAncestor)(node, 'JSXAttribute');
            const attrName = getAttrName((_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.name);
            // allow <MyComponent className="active" />
            if (userJSXAttrs.includes(getAttrName((_b = parent === null || parent === void 0 ? void 0 : parent.name) === null || _b === void 0 ? void 0 : _b.name))) {
                visited.add(node);
                return;
            }
            const jsxElement = (0, helpers_1.getNearestAncestor)(node, 'JSXOpeningElement');
            const tagName = (0, helpers_1.getIdentifierName)(jsxElement === null || jsxElement === void 0 ? void 0 : jsxElement.name);
            const attributeNames = jsxElement === null || jsxElement === void 0 ? void 0 : jsxElement.attributes.map((attr) => { var _a; return attr.type === utils_1.TSESTree.AST_NODE_TYPES.JSXAttribute && getAttrName((_a = attr === null || attr === void 0 ? void 0 : attr.name) === null || _a === void 0 ? void 0 : _a.name); });
            if ((0, helpers_1.isAllowedDOMAttr)(tagName, attrName, attributeNames)) {
                visited.add(node);
            }
        };
        const onProperty = (node) => {
            var _a, _b, _c, _d, _e, _f, _g, _h;
            const { parent } = node;
            if (parent.type === utils_1.TSESTree.AST_NODE_TYPES.Property) {
                // if node is key of property, skip
                if ((parent === null || parent === void 0 ? void 0 : parent.key) === node) {
                    visited.add(node);
                }
                // name if key is Identifier; value if key is Literal
                // dont care whether if this is computed or not
                if (((_a = parent === null || parent === void 0 ? void 0 : parent.key) === null || _a === void 0 ? void 0 : _a.type) === utils_1.TSESTree.AST_NODE_TYPES.Identifier &&
                    ((0, helpers_1.isUpperCase)((_b = parent === null || parent === void 0 ? void 0 : parent.key) === null || _b === void 0 ? void 0 : _b.name) || userProperties.includes((_c = parent === null || parent === void 0 ? void 0 : parent.key) === null || _c === void 0 ? void 0 : _c.name))) {
                    visited.add(node);
                }
                if (((_d = parent === null || parent === void 0 ? void 0 : parent.key) === null || _d === void 0 ? void 0 : _d.type) === utils_1.TSESTree.AST_NODE_TYPES.Literal &&
                    (0, helpers_1.isUpperCase)(`${(_e = parent === null || parent === void 0 ? void 0 : parent.key) === null || _e === void 0 ? void 0 : _e.value}`)) {
                    visited.add(node);
                }
                if (((_f = parent === null || parent === void 0 ? void 0 : parent.value) === null || _f === void 0 ? void 0 : _f.type) === utils_1.TSESTree.AST_NODE_TYPES.Literal &&
                    (0, helpers_1.isUpperCase)(`${(_g = parent === null || parent === void 0 ? void 0 : parent.value) === null || _g === void 0 ? void 0 : _g.value}`)) {
                    visited.add(node);
                }
                if (((_h = parent === null || parent === void 0 ? void 0 : parent.key) === null || _h === void 0 ? void 0 : _h.type) === utils_1.TSESTree.AST_NODE_TYPES.TemplateLiteral &&
                    (0, helpers_1.isUpperCase)((0, helpers_1.getQuasisValue)(parent === null || parent === void 0 ? void 0 : parent.key))) {
                    visited.add(node);
                }
            }
        };
        const onBinaryExpression = (node) => {
            if (node.parent.type === utils_1.TSESTree.AST_NODE_TYPES.BinaryExpression) {
                const { parent: { operator }, } = node;
                // allow name === 'String'
                if (operator !== '+') {
                    visited.add(node);
                }
            }
        };
        const onCallExpression = (node, parentName) => {
            const parent = utils_1.TSESTree.AST_NODE_TYPES.CallExpression === parentName
                ? (0, helpers_1.getNearestAncestor)(node, parentName)
                : (0, helpers_1.getNearestAncestor)(node, parentName);
            if (isValidFunctionCall(parent))
                visited.add(node);
        };
        const onClassProperty = (node) => {
            const { parent } = node;
            if ((parent.type === utils_1.TSESTree.AST_NODE_TYPES.Property ||
                parent.type === utils_1.TSESTree.AST_NODE_TYPES.PropertyDefinition ||
                //@ts-ignore
                parent.type === 'ClassProperty') &&
                parent.key.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier) {
                if ((parent === null || parent === void 0 ? void 0 : parent.key) && ignoredClassProperties.includes(parent.key.name)) {
                    visited.add(node);
                }
            }
        };
        const processTextNode = (node, text) => {
            visited.add(node);
            const userJSXElement = [...ignoredJSXElements];
            function isUserJSXElement(node) {
                return userJSXElement.some((name) => (0, helpers_1.hasAncestorWithName)(node, name));
            }
            function isIgnoredSymbol(str) {
                return ignoredJSXSymbols.some((name) => name === str);
            }
            if (!text || match(text) || isUserJSXElement(node) || isIgnoredSymbol(text)) {
                return;
            }
            context.report({ node, messageId: 'default', data: { message } });
        };
        const literalVisitor = {
            'ImportDeclaration Literal'(node) {
                // allow (import abc form 'abc')
                visited.add(node);
            },
            'ExportAllDeclaration Literal'(node) {
                // allow export * from 'mod'
                visited.add(node);
            },
            'ExportNamedDeclaration > Literal'(node) {
                // allow export { named } from 'mod'
                visited.add(node);
            },
            'JSXElement > Literal'(node) {
                processTextNode(node, `${node.value}`.trim());
            },
            'JSXElement > JSXExpressionContainer > Literal'(node) {
                processTextNode(node, `${node.value}`.trim());
            },
            'JSXAttribute Literal'(node) {
                onJSXAttribute(node);
            },
            'TSLiteralType Literal'(node) {
                // allow var a: Type['member'];
                visited.add(node);
            },
            // ─────────────────────────────────────────────────────────────────
            'ClassProperty > Literal'(node) {
                onClassProperty(node);
            },
            'TSEnumMember > Literal'(node) {
                visited.add(node);
            },
            'VariableDeclarator > Literal'(node) {
                // allow statements like const A_B = "test"
                if (node.parent.type === utils_1.TSESTree.AST_NODE_TYPES.VariableDeclarator &&
                    node.parent.id.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier &&
                    (0, helpers_1.isUpperCase)(node.parent.id.name)) {
                    visited.add(node);
                }
            },
            'Property > Literal'(node) {
                onProperty(node);
            },
            'BinaryExpression > Literal'(node) {
                onBinaryExpression(node);
            },
            'CallExpression Literal'(node) {
                onCallExpression(node, utils_1.TSESTree.AST_NODE_TYPES.CallExpression);
            },
            'NewExpression Literal'(node) {
                onCallExpression(node, utils_1.TSESTree.AST_NODE_TYPES.NewExpression);
            },
            'SwitchCase > Literal'(node) {
                visited.add(node);
            },
            'TaggedTemplateExpression > TemplateLiteral Literal'(node) {
                visited.add(node);
            },
            'Literal:exit'(node) {
                // visited and passed linting
                if (visited.has(node))
                    return;
                const trimed = `${node.value}`.trim();
                if (!trimed)
                    return;
                // allow statements like const a = "FOO"
                if ((0, helpers_1.isUpperCase)(trimed))
                    return;
                if (match(trimed) || !isStrMatched(trimed))
                    return;
                //
                // TYPESCRIPT
                //
                if (typeChecker) {
                    const tsNode = esTreeNodeToTSNodeMap.get(node);
                    const typeObj = typeChecker.getTypeAtLocation(tsNode.parent);
                    // var a: 'abc' = 'abc'
                    if (typeObj.isStringLiteral() && typeObj.symbol) {
                        return;
                    }
                }
                context.report({ node, messageId: 'default', data: { message } });
            },
        };
        const templateLiteralVisitor = {
            'JSXElement > JSXExpressionContainer > TemplateLiteral'(node) {
                processTextNode(node, (0, helpers_1.getQuasisValue)(node));
            },
            'JSXAttribute TemplateLiteral'(node) {
                onJSXAttribute(node);
            },
            'ClassProperty > TemplateLiteral'(node) {
                onClassProperty(node);
            },
            'TSEnumMember > TemplateLiteral'(node) {
                visited.add(node);
            },
            'VariableDeclarator > TemplateLiteral'(node) {
                // allow statements like const A_B = `test`
                if (node.parent.type === utils_1.TSESTree.AST_NODE_TYPES.VariableDeclarator &&
                    node.parent.id.type === utils_1.TSESTree.AST_NODE_TYPES.Identifier &&
                    (0, helpers_1.isUpperCase)(node.parent.id.name)) {
                    visited.add(node);
                }
            },
            'Property > TemplateLiteral'(node) {
                onProperty(node);
            },
            'BinaryExpression > TemplateLiteral'(node) {
                onBinaryExpression(node);
            },
            'CallExpression TemplateLiteral'(node) {
                onCallExpression(node, utils_1.TSESTree.AST_NODE_TYPES.CallExpression);
            },
            'NewExpression TemplateLiteral'(node) {
                onCallExpression(node, utils_1.TSESTree.AST_NODE_TYPES.NewExpression);
            },
            'SwitchCase > TemplateLiteral'(node) {
                visited.add(node);
            },
            'TaggedTemplateExpression > TemplateLiteral'(node) {
                visited.add(node);
            },
            'TaggedTemplateExpression > TemplateLiteral TemplateLiteral'(node) {
                visited.add(node);
            },
            'TemplateLiteral:exit'(node) {
                if (visited.has(node))
                    return;
                const quasisValue = (0, helpers_1.getQuasisValue)(node);
                if ((0, helpers_1.isUpperCase)(quasisValue))
                    return;
                if (match(quasisValue) || !isStrMatched(quasisValue))
                    return;
                context.report({ node, messageId: 'default', data: { message } });
            },
        };
        const jsxTextLiteralVisitor = {
            JSXText(node) {
                processTextNode(node, `${node.value}`.trim());
            },
        };
        function wrapVisitor(visitor) {
            const newVisitor = {};
            Object.keys(visitor).forEach((key) => {
                const old = visitor[key];
                newVisitor[key] = (node) => {
                    // make sure node is string literal
                    if (!isString(node))
                        return;
                    old(node);
                };
            });
            return newVisitor;
        }
        return {
            ...wrapVisitor(literalVisitor),
            ...wrapVisitor(templateLiteralVisitor),
            ...wrapVisitor(jsxTextLiteralVisitor),
        };
    },
};
const popularCallee = [
    'addEventListener',
    'removeEventListener',
    'postMessage',
    'getElementById',
    'dispatch',
    'commit',
    'includes',
    'indexOf',
    'endsWith',
    'startsWith',
];
function generateCalleeWhitelists(option) {
    const ignoreFunction = (option && option.ignoreFunction) || [];
    const result = {
        simple: ['t', 'plural', 'select', ...popularCallee],
        complex: ['i18n._'],
    };
    ignoreFunction.forEach((item) => {
        if (item.indexOf('.') !== -1) {
            result.complex.push(item);
        }
        else {
            result.simple.push(item);
        }
    });
    return result;
}
exports.default = rule;
//# sourceMappingURL=no-unlocalized-strings.js.map